// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMPILEDMODEL_TFLITE_GPU_GL_DATA_H_
#define FLATBUFFERS_GENERATED_COMPILEDMODEL_TFLITE_GPU_GL_DATA_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace tflite {
namespace gpu {
namespace gl {
namespace data {

struct Program;
struct ProgramBuilder;
struct ProgramT;

struct ProgramBinary;
struct ProgramBinaryBuilder;
struct ProgramBinaryT;

struct DataFloat;
struct DataFloatBuilder;
struct DataFloatT;

struct DataInt32;
struct DataInt32Builder;
struct DataInt32T;

struct DataUint32;
struct DataUint32Builder;
struct DataUint32T;

struct UniformParameter;
struct UniformParameterBuilder;
struct UniformParameterT;

struct Object;
struct ObjectBuilder;
struct ObjectT;

struct ObjectRef;
struct ObjectRefBuilder;
struct ObjectRefT;

struct ObjectData;
struct ObjectDataBuilder;
struct ObjectDataT;

struct CompiledModel;
struct CompiledModelBuilder;
struct CompiledModelT;

struct Parameters;
struct ParametersBuilder;
struct ParametersT;

enum class ParameterType : int8_t {
  INT32 = 0,
  UINT32 = 1,
  FLOAT32 = 2,
  INT32_2 = 3,
  MIN = INT32,
  MAX = INT32_2
};

inline const ParameterType (&EnumValuesParameterType())[4] {
  static const ParameterType values[] = {
    ParameterType::INT32,
    ParameterType::UINT32,
    ParameterType::FLOAT32,
    ParameterType::INT32_2
  };
  return values;
}

inline const char * const *EnumNamesParameterType() {
  static const char * const names[5] = {
    "INT32",
    "UINT32",
    "FLOAT32",
    "INT32_2",
    nullptr
  };
  return names;
}

inline const char *EnumNameParameterType(ParameterType e) {
  if (flatbuffers::IsOutRange(e, ParameterType::INT32, ParameterType::INT32_2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesParameterType()[index];
}

enum class DataType : int8_t {
  UNKNOWN = 0,
  FLOAT32 = 1,
  FLOAT16 = 2,
  INT32 = 3,
  INT16 = 4,
  MIN = UNKNOWN,
  MAX = INT16
};

inline const DataType (&EnumValuesDataType())[5] {
  static const DataType values[] = {
    DataType::UNKNOWN,
    DataType::FLOAT32,
    DataType::FLOAT16,
    DataType::INT32,
    DataType::INT16
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[6] = {
    "UNKNOWN",
    "FLOAT32",
    "FLOAT16",
    "INT32",
    "INT16",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType::UNKNOWN, DataType::INT16)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class DataVariant : uint8_t {
  NONE = 0,
  DataInt32 = 1,
  DataFloat = 2,
  DataUint32 = 3,
  MIN = NONE,
  MAX = DataUint32
};

inline const DataVariant (&EnumValuesDataVariant())[4] {
  static const DataVariant values[] = {
    DataVariant::NONE,
    DataVariant::DataInt32,
    DataVariant::DataFloat,
    DataVariant::DataUint32
  };
  return values;
}

inline const char * const *EnumNamesDataVariant() {
  static const char * const names[5] = {
    "NONE",
    "DataInt32",
    "DataFloat",
    "DataUint32",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataVariant(DataVariant e) {
  if (flatbuffers::IsOutRange(e, DataVariant::NONE, DataVariant::DataUint32)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataVariant()[index];
}

template<typename T> struct DataVariantTraits {
  static const DataVariant enum_value = DataVariant::NONE;
};

template<> struct DataVariantTraits<tflite::gpu::gl::data::DataInt32> {
  static const DataVariant enum_value = DataVariant::DataInt32;
};

template<> struct DataVariantTraits<tflite::gpu::gl::data::DataFloat> {
  static const DataVariant enum_value = DataVariant::DataFloat;
};

template<> struct DataVariantTraits<tflite::gpu::gl::data::DataUint32> {
  static const DataVariant enum_value = DataVariant::DataUint32;
};

struct DataVariantUnion {
  DataVariant type;
  void *value;

  DataVariantUnion() : type(DataVariant::NONE), value(nullptr) {}
  DataVariantUnion(DataVariantUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(DataVariant::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  DataVariantUnion(const DataVariantUnion &);
  DataVariantUnion &operator=(const DataVariantUnion &u)
    { DataVariantUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  DataVariantUnion &operator=(DataVariantUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~DataVariantUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = DataVariantTraits<typename RT::TableType>::enum_value;
    if (type != DataVariant::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, DataVariant type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::gpu::gl::data::DataInt32T *AsDataInt32() {
    return type == DataVariant::DataInt32 ?
      reinterpret_cast<tflite::gpu::gl::data::DataInt32T *>(value) : nullptr;
  }
  const tflite::gpu::gl::data::DataInt32T *AsDataInt32() const {
    return type == DataVariant::DataInt32 ?
      reinterpret_cast<const tflite::gpu::gl::data::DataInt32T *>(value) : nullptr;
  }
  tflite::gpu::gl::data::DataFloatT *AsDataFloat() {
    return type == DataVariant::DataFloat ?
      reinterpret_cast<tflite::gpu::gl::data::DataFloatT *>(value) : nullptr;
  }
  const tflite::gpu::gl::data::DataFloatT *AsDataFloat() const {
    return type == DataVariant::DataFloat ?
      reinterpret_cast<const tflite::gpu::gl::data::DataFloatT *>(value) : nullptr;
  }
  tflite::gpu::gl::data::DataUint32T *AsDataUint32() {
    return type == DataVariant::DataUint32 ?
      reinterpret_cast<tflite::gpu::gl::data::DataUint32T *>(value) : nullptr;
  }
  const tflite::gpu::gl::data::DataUint32T *AsDataUint32() const {
    return type == DataVariant::DataUint32 ?
      reinterpret_cast<const tflite::gpu::gl::data::DataUint32T *>(value) : nullptr;
  }
};

bool VerifyDataVariant(flatbuffers::Verifier &verifier, const void *obj, DataVariant type);
bool VerifyDataVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class AccessType : int8_t {
  READ = 0,
  WRITE = 1,
  READ_WRITE = 2,
  MIN = READ,
  MAX = READ_WRITE
};

inline const AccessType (&EnumValuesAccessType())[3] {
  static const AccessType values[] = {
    AccessType::READ,
    AccessType::WRITE,
    AccessType::READ_WRITE
  };
  return values;
}

inline const char * const *EnumNamesAccessType() {
  static const char * const names[4] = {
    "READ",
    "WRITE",
    "READ_WRITE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAccessType(AccessType e) {
  if (flatbuffers::IsOutRange(e, AccessType::READ, AccessType::READ_WRITE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAccessType()[index];
}

enum class ObjectType : int8_t {
  UNKNOWN = 0,
  BUFFER = 1,
  TEXTURE = 2,
  MIN = UNKNOWN,
  MAX = TEXTURE
};

inline const ObjectType (&EnumValuesObjectType())[3] {
  static const ObjectType values[] = {
    ObjectType::UNKNOWN,
    ObjectType::BUFFER,
    ObjectType::TEXTURE
  };
  return values;
}

inline const char * const *EnumNamesObjectType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "BUFFER",
    "TEXTURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectType(ObjectType e) {
  if (flatbuffers::IsOutRange(e, ObjectType::UNKNOWN, ObjectType::TEXTURE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectType()[index];
}

enum class ObjectVariant : uint8_t {
  NONE = 0,
  ObjectData = 1,
  ObjectRef = 2,
  MIN = NONE,
  MAX = ObjectRef
};

inline const ObjectVariant (&EnumValuesObjectVariant())[3] {
  static const ObjectVariant values[] = {
    ObjectVariant::NONE,
    ObjectVariant::ObjectData,
    ObjectVariant::ObjectRef
  };
  return values;
}

inline const char * const *EnumNamesObjectVariant() {
  static const char * const names[4] = {
    "NONE",
    "ObjectData",
    "ObjectRef",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectVariant(ObjectVariant e) {
  if (flatbuffers::IsOutRange(e, ObjectVariant::NONE, ObjectVariant::ObjectRef)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectVariant()[index];
}

template<typename T> struct ObjectVariantTraits {
  static const ObjectVariant enum_value = ObjectVariant::NONE;
};

template<> struct ObjectVariantTraits<tflite::gpu::gl::data::ObjectData> {
  static const ObjectVariant enum_value = ObjectVariant::ObjectData;
};

template<> struct ObjectVariantTraits<tflite::gpu::gl::data::ObjectRef> {
  static const ObjectVariant enum_value = ObjectVariant::ObjectRef;
};

struct ObjectVariantUnion {
  ObjectVariant type;
  void *value;

  ObjectVariantUnion() : type(ObjectVariant::NONE), value(nullptr) {}
  ObjectVariantUnion(ObjectVariantUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ObjectVariant::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ObjectVariantUnion(const ObjectVariantUnion &);
  ObjectVariantUnion &operator=(const ObjectVariantUnion &u)
    { ObjectVariantUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ObjectVariantUnion &operator=(ObjectVariantUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ObjectVariantUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ObjectVariantTraits<typename RT::TableType>::enum_value;
    if (type != ObjectVariant::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ObjectVariant type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::gpu::gl::data::ObjectDataT *AsObjectData() {
    return type == ObjectVariant::ObjectData ?
      reinterpret_cast<tflite::gpu::gl::data::ObjectDataT *>(value) : nullptr;
  }
  const tflite::gpu::gl::data::ObjectDataT *AsObjectData() const {
    return type == ObjectVariant::ObjectData ?
      reinterpret_cast<const tflite::gpu::gl::data::ObjectDataT *>(value) : nullptr;
  }
  tflite::gpu::gl::data::ObjectRefT *AsObjectRef() {
    return type == ObjectVariant::ObjectRef ?
      reinterpret_cast<tflite::gpu::gl::data::ObjectRefT *>(value) : nullptr;
  }
  const tflite::gpu::gl::data::ObjectRefT *AsObjectRef() const {
    return type == ObjectVariant::ObjectRef ?
      reinterpret_cast<const tflite::gpu::gl::data::ObjectRefT *>(value) : nullptr;
  }
};

bool VerifyObjectVariant(flatbuffers::Verifier &verifier, const void *obj, ObjectVariant type);
bool VerifyObjectVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class ObjectSize : uint8_t {
  NONE = 0,
  Uint1 = 1,
  Uint2 = 2,
  Uint3 = 3,
  MIN = NONE,
  MAX = Uint3
};

inline const ObjectSize (&EnumValuesObjectSize())[4] {
  static const ObjectSize values[] = {
    ObjectSize::NONE,
    ObjectSize::Uint1,
    ObjectSize::Uint2,
    ObjectSize::Uint3
  };
  return values;
}

inline const char * const *EnumNamesObjectSize() {
  static const char * const names[5] = {
    "NONE",
    "Uint1",
    "Uint2",
    "Uint3",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectSize(ObjectSize e) {
  if (flatbuffers::IsOutRange(e, ObjectSize::NONE, ObjectSize::Uint3)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectSize()[index];
}

template<typename T> struct ObjectSizeTraits {
  static const ObjectSize enum_value = ObjectSize::NONE;
};

template<> struct ObjectSizeTraits<tflite::gpu::gl::data::Uint1> {
  static const ObjectSize enum_value = ObjectSize::Uint1;
};

template<> struct ObjectSizeTraits<tflite::gpu::gl::data::Uint2> {
  static const ObjectSize enum_value = ObjectSize::Uint2;
};

template<> struct ObjectSizeTraits<tflite::gpu::gl::data::Uint3> {
  static const ObjectSize enum_value = ObjectSize::Uint3;
};

struct ObjectSizeUnion {
  ObjectSize type;
  void *value;

  ObjectSizeUnion() : type(ObjectSize::NONE), value(nullptr) {}
  ObjectSizeUnion(ObjectSizeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ObjectSize::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ObjectSizeUnion(const ObjectSizeUnion &);
  ObjectSizeUnion &operator=(const ObjectSizeUnion &u)
    { ObjectSizeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ObjectSizeUnion &operator=(ObjectSizeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ObjectSizeUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ObjectSizeTraits<typename RT::TableType>::enum_value;
    if (type != ObjectSize::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ObjectSize type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  tflite::gpu::gl::data::Uint1T *AsUint1() {
    return type == ObjectSize::Uint1 ?
      reinterpret_cast<tflite::gpu::gl::data::Uint1T *>(value) : nullptr;
  }
  const tflite::gpu::gl::data::Uint1T *AsUint1() const {
    return type == ObjectSize::Uint1 ?
      reinterpret_cast<const tflite::gpu::gl::data::Uint1T *>(value) : nullptr;
  }
  tflite::gpu::gl::data::Uint2T *AsUint2() {
    return type == ObjectSize::Uint2 ?
      reinterpret_cast<tflite::gpu::gl::data::Uint2T *>(value) : nullptr;
  }
  const tflite::gpu::gl::data::Uint2T *AsUint2() const {
    return type == ObjectSize::Uint2 ?
      reinterpret_cast<const tflite::gpu::gl::data::Uint2T *>(value) : nullptr;
  }
  tflite::gpu::gl::data::Uint3T *AsUint3() {
    return type == ObjectSize::Uint3 ?
      reinterpret_cast<tflite::gpu::gl::data::Uint3T *>(value) : nullptr;
  }
  const tflite::gpu::gl::data::Uint3T *AsUint3() const {
    return type == ObjectSize::Uint3 ?
      reinterpret_cast<const tflite::gpu::gl::data::Uint3T *>(value) : nullptr;
  }
};

bool VerifyObjectSize(flatbuffers::Verifier &verifier, const void *obj, ObjectSize type);
bool VerifyObjectSizeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ProgramT : public flatbuffers::NativeTable {
  typedef Program TableType;
  std::vector<std::unique_ptr<tflite::gpu::gl::data::ObjectT>> objects{};
  std::vector<std::unique_ptr<tflite::gpu::gl::data::UniformParameterT>> parameters{};
  std::unique_ptr<tflite::gpu::gl::data::Uint3T> number_workgroups{};
  std::unique_ptr<tflite::gpu::gl::data::Uint3T> workgroup_size{};
  uint32_t shader_index = 0;
  std::unique_ptr<tflite::gpu::gl::data::ProgramBinaryT> binary{};
};

struct Program FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgramT NativeTableType;
  typedef ProgramBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTS = 4,
    VT_PARAMETERS = 6,
    VT_NUMBER_WORKGROUPS = 8,
    VT_WORKGROUP_SIZE = 10,
    VT_SHADER_INDEX = 12,
    VT_BINARY = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::Object>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::Object>> *>(VT_OBJECTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::UniformParameter>> *parameters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::UniformParameter>> *>(VT_PARAMETERS);
  }
  const tflite::gpu::gl::data::Uint3 *number_workgroups() const {
    return GetPointer<const tflite::gpu::gl::data::Uint3 *>(VT_NUMBER_WORKGROUPS);
  }
  const tflite::gpu::gl::data::Uint3 *workgroup_size() const {
    return GetPointer<const tflite::gpu::gl::data::Uint3 *>(VT_WORKGROUP_SIZE);
  }
  uint32_t shader_index() const {
    return GetField<uint32_t>(VT_SHADER_INDEX, 0);
  }
  const tflite::gpu::gl::data::ProgramBinary *binary() const {
    return GetPointer<const tflite::gpu::gl::data::ProgramBinary *>(VT_BINARY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           VerifyOffset(verifier, VT_NUMBER_WORKGROUPS) &&
           verifier.VerifyTable(number_workgroups()) &&
           VerifyOffset(verifier, VT_WORKGROUP_SIZE) &&
           verifier.VerifyTable(workgroup_size()) &&
           VerifyField<uint32_t>(verifier, VT_SHADER_INDEX) &&
           VerifyOffset(verifier, VT_BINARY) &&
           verifier.VerifyTable(binary()) &&
           verifier.EndTable();
  }
  ProgramT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProgramT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Program> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgramT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProgramBuilder {
  typedef Program Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::Object>>> objects) {
    fbb_.AddOffset(Program::VT_OBJECTS, objects);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::UniformParameter>>> parameters) {
    fbb_.AddOffset(Program::VT_PARAMETERS, parameters);
  }
  void add_number_workgroups(flatbuffers::Offset<tflite::gpu::gl::data::Uint3> number_workgroups) {
    fbb_.AddOffset(Program::VT_NUMBER_WORKGROUPS, number_workgroups);
  }
  void add_workgroup_size(flatbuffers::Offset<tflite::gpu::gl::data::Uint3> workgroup_size) {
    fbb_.AddOffset(Program::VT_WORKGROUP_SIZE, workgroup_size);
  }
  void add_shader_index(uint32_t shader_index) {
    fbb_.AddElement<uint32_t>(Program::VT_SHADER_INDEX, shader_index, 0);
  }
  void add_binary(flatbuffers::Offset<tflite::gpu::gl::data::ProgramBinary> binary) {
    fbb_.AddOffset(Program::VT_BINARY, binary);
  }
  explicit ProgramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Program> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Program>(end);
    return o;
  }
};

inline flatbuffers::Offset<Program> CreateProgram(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::Object>>> objects = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::UniformParameter>>> parameters = 0,
    flatbuffers::Offset<tflite::gpu::gl::data::Uint3> number_workgroups = 0,
    flatbuffers::Offset<tflite::gpu::gl::data::Uint3> workgroup_size = 0,
    uint32_t shader_index = 0,
    flatbuffers::Offset<tflite::gpu::gl::data::ProgramBinary> binary = 0) {
  ProgramBuilder builder_(_fbb);
  builder_.add_binary(binary);
  builder_.add_shader_index(shader_index);
  builder_.add_workgroup_size(workgroup_size);
  builder_.add_number_workgroups(number_workgroups);
  builder_.add_parameters(parameters);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline flatbuffers::Offset<Program> CreateProgramDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<tflite::gpu::gl::data::Object>> *objects = nullptr,
    const std::vector<flatbuffers::Offset<tflite::gpu::gl::data::UniformParameter>> *parameters = nullptr,
    flatbuffers::Offset<tflite::gpu::gl::data::Uint3> number_workgroups = 0,
    flatbuffers::Offset<tflite::gpu::gl::data::Uint3> workgroup_size = 0,
    uint32_t shader_index = 0,
    flatbuffers::Offset<tflite::gpu::gl::data::ProgramBinary> binary = 0) {
  auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::gl::data::Object>>(*objects) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::gl::data::UniformParameter>>(*parameters) : 0;
  return tflite::gpu::gl::data::CreateProgram(
      _fbb,
      objects__,
      parameters__,
      number_workgroups,
      workgroup_size,
      shader_index,
      binary);
}

flatbuffers::Offset<Program> CreateProgram(flatbuffers::FlatBufferBuilder &_fbb, const ProgramT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProgramBinaryT : public flatbuffers::NativeTable {
  typedef ProgramBinary TableType;
  uint32_t format = 0;
  std::vector<uint8_t> binary{};
};

struct ProgramBinary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgramBinaryT NativeTableType;
  typedef ProgramBinaryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_BINARY = 6
  };
  uint32_t format() const {
    return GetField<uint32_t>(VT_FORMAT, 0);
  }
  const flatbuffers::Vector<uint8_t> *binary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BINARY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_BINARY) &&
           verifier.VerifyVector(binary()) &&
           verifier.EndTable();
  }
  ProgramBinaryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProgramBinaryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProgramBinary> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgramBinaryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProgramBinaryBuilder {
  typedef ProgramBinary Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(uint32_t format) {
    fbb_.AddElement<uint32_t>(ProgramBinary::VT_FORMAT, format, 0);
  }
  void add_binary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary) {
    fbb_.AddOffset(ProgramBinary::VT_BINARY, binary);
  }
  explicit ProgramBinaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProgramBinary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProgramBinary>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProgramBinary> CreateProgramBinary(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t format = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary = 0) {
  ProgramBinaryBuilder builder_(_fbb);
  builder_.add_binary(binary);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgramBinary> CreateProgramBinaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t format = 0,
    const std::vector<uint8_t> *binary = nullptr) {
  auto binary__ = binary ? _fbb.CreateVector<uint8_t>(*binary) : 0;
  return tflite::gpu::gl::data::CreateProgramBinary(
      _fbb,
      format,
      binary__);
}

flatbuffers::Offset<ProgramBinary> CreateProgramBinary(flatbuffers::FlatBufferBuilder &_fbb, const ProgramBinaryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DataFloatT : public flatbuffers::NativeTable {
  typedef DataFloat TableType;
  std::vector<float> data{};
};

struct DataFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFloatT NativeTableType;
  typedef DataFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  DataFloatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DataFloatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DataFloat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DataFloatBuilder {
  typedef DataFloat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(DataFloat::VT_DATA, data);
  }
  explicit DataFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFloat> CreateDataFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  DataFloatBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataFloat> CreateDataFloatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return tflite::gpu::gl::data::CreateDataFloat(
      _fbb,
      data__);
}

flatbuffers::Offset<DataFloat> CreateDataFloat(flatbuffers::FlatBufferBuilder &_fbb, const DataFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DataInt32T : public flatbuffers::NativeTable {
  typedef DataInt32 TableType;
  std::vector<int32_t> data{};
};

struct DataInt32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataInt32T NativeTableType;
  typedef DataInt32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<int32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  DataInt32T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DataInt32T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DataInt32> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataInt32T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DataInt32Builder {
  typedef DataInt32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> data) {
    fbb_.AddOffset(DataInt32::VT_DATA, data);
  }
  explicit DataInt32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataInt32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataInt32>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataInt32> CreateDataInt32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> data = 0) {
  DataInt32Builder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataInt32> CreateDataInt32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int32_t>(*data) : 0;
  return tflite::gpu::gl::data::CreateDataInt32(
      _fbb,
      data__);
}

flatbuffers::Offset<DataInt32> CreateDataInt32(flatbuffers::FlatBufferBuilder &_fbb, const DataInt32T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DataUint32T : public flatbuffers::NativeTable {
  typedef DataUint32 TableType;
  std::vector<uint32_t> data{};
};

struct DataUint32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataUint32T NativeTableType;
  typedef DataUint32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  DataUint32T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DataUint32T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DataUint32> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataUint32T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DataUint32Builder {
  typedef DataUint32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(DataUint32::VT_DATA, data);
  }
  explicit DataUint32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataUint32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataUint32>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataUint32> CreateDataUint32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  DataUint32Builder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataUint32> CreateDataUint32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return tflite::gpu::gl::data::CreateDataUint32(
      _fbb,
      data__);
}

flatbuffers::Offset<DataUint32> CreateDataUint32(flatbuffers::FlatBufferBuilder &_fbb, const DataUint32T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniformParameterT : public flatbuffers::NativeTable {
  typedef UniformParameter TableType;
  std::string name{};
  tflite::gpu::gl::data::ParameterType type = tflite::gpu::gl::data::ParameterType::INT32;
  tflite::gpu::gl::data::DataVariantUnion data{};
};

struct UniformParameter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UniformParameterT NativeTableType;
  typedef UniformParameterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  tflite::gpu::gl::data::ParameterType type() const {
    return static_cast<tflite::gpu::gl::data::ParameterType>(GetField<int8_t>(VT_TYPE, 0));
  }
  tflite::gpu::gl::data::DataVariant data_type() const {
    return static_cast<tflite::gpu::gl::data::DataVariant>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const tflite::gpu::gl::data::DataInt32 *data_as_DataInt32() const {
    return data_type() == tflite::gpu::gl::data::DataVariant::DataInt32 ? static_cast<const tflite::gpu::gl::data::DataInt32 *>(data()) : nullptr;
  }
  const tflite::gpu::gl::data::DataFloat *data_as_DataFloat() const {
    return data_type() == tflite::gpu::gl::data::DataVariant::DataFloat ? static_cast<const tflite::gpu::gl::data::DataFloat *>(data()) : nullptr;
  }
  const tflite::gpu::gl::data::DataUint32 *data_as_DataUint32() const {
    return data_type() == tflite::gpu::gl::data::DataVariant::DataUint32 ? static_cast<const tflite::gpu::gl::data::DataUint32 *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyDataVariant(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  UniformParameterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniformParameterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UniformParameter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniformParameterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const tflite::gpu::gl::data::DataInt32 *UniformParameter::data_as<tflite::gpu::gl::data::DataInt32>() const {
  return data_as_DataInt32();
}

template<> inline const tflite::gpu::gl::data::DataFloat *UniformParameter::data_as<tflite::gpu::gl::data::DataFloat>() const {
  return data_as_DataFloat();
}

template<> inline const tflite::gpu::gl::data::DataUint32 *UniformParameter::data_as<tflite::gpu::gl::data::DataUint32>() const {
  return data_as_DataUint32();
}

struct UniformParameterBuilder {
  typedef UniformParameter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UniformParameter::VT_NAME, name);
  }
  void add_type(tflite::gpu::gl::data::ParameterType type) {
    fbb_.AddElement<int8_t>(UniformParameter::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_data_type(tflite::gpu::gl::data::DataVariant data_type) {
    fbb_.AddElement<uint8_t>(UniformParameter::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(UniformParameter::VT_DATA, data);
  }
  explicit UniformParameterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UniformParameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniformParameter>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniformParameter> CreateUniformParameter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    tflite::gpu::gl::data::ParameterType type = tflite::gpu::gl::data::ParameterType::INT32,
    tflite::gpu::gl::data::DataVariant data_type = tflite::gpu::gl::data::DataVariant::NONE,
    flatbuffers::Offset<void> data = 0) {
  UniformParameterBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_name(name);
  builder_.add_data_type(data_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<UniformParameter> CreateUniformParameterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    tflite::gpu::gl::data::ParameterType type = tflite::gpu::gl::data::ParameterType::INT32,
    tflite::gpu::gl::data::DataVariant data_type = tflite::gpu::gl::data::DataVariant::NONE,
    flatbuffers::Offset<void> data = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::gpu::gl::data::CreateUniformParameter(
      _fbb,
      name__,
      type,
      data_type,
      data);
}

flatbuffers::Offset<UniformParameter> CreateUniformParameter(flatbuffers::FlatBufferBuilder &_fbb, const UniformParameterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ObjectT : public flatbuffers::NativeTable {
  typedef Object TableType;
  tflite::gpu::gl::data::AccessType access = tflite::gpu::gl::data::AccessType::READ;
  uint32_t binding = 0;
  tflite::gpu::gl::data::DataType data_type = tflite::gpu::gl::data::DataType::UNKNOWN;
  tflite::gpu::gl::data::ObjectType type = tflite::gpu::gl::data::ObjectType::UNKNOWN;
  tflite::gpu::gl::data::ObjectSizeUnion size{};
  tflite::gpu::gl::data::ObjectVariantUnion object{};
};

struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectT NativeTableType;
  typedef ObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCESS = 4,
    VT_BINDING = 6,
    VT_DATA_TYPE = 8,
    VT_TYPE = 10,
    VT_SIZE_TYPE = 12,
    VT_SIZE = 14,
    VT_OBJECT_TYPE = 16,
    VT_OBJECT = 18
  };
  tflite::gpu::gl::data::AccessType access() const {
    return static_cast<tflite::gpu::gl::data::AccessType>(GetField<int8_t>(VT_ACCESS, 0));
  }
  uint32_t binding() const {
    return GetField<uint32_t>(VT_BINDING, 0);
  }
  tflite::gpu::gl::data::DataType data_type() const {
    return static_cast<tflite::gpu::gl::data::DataType>(GetField<int8_t>(VT_DATA_TYPE, 0));
  }
  tflite::gpu::gl::data::ObjectType type() const {
    return static_cast<tflite::gpu::gl::data::ObjectType>(GetField<int8_t>(VT_TYPE, 0));
  }
  tflite::gpu::gl::data::ObjectSize size_type() const {
    return static_cast<tflite::gpu::gl::data::ObjectSize>(GetField<uint8_t>(VT_SIZE_TYPE, 0));
  }
  const void *size() const {
    return GetPointer<const void *>(VT_SIZE);
  }
  template<typename T> const T *size_as() const;
  const tflite::gpu::gl::data::Uint1 *size_as_Uint1() const {
    return size_type() == tflite::gpu::gl::data::ObjectSize::Uint1 ? static_cast<const tflite::gpu::gl::data::Uint1 *>(size()) : nullptr;
  }
  const tflite::gpu::gl::data::Uint2 *size_as_Uint2() const {
    return size_type() == tflite::gpu::gl::data::ObjectSize::Uint2 ? static_cast<const tflite::gpu::gl::data::Uint2 *>(size()) : nullptr;
  }
  const tflite::gpu::gl::data::Uint3 *size_as_Uint3() const {
    return size_type() == tflite::gpu::gl::data::ObjectSize::Uint3 ? static_cast<const tflite::gpu::gl::data::Uint3 *>(size()) : nullptr;
  }
  tflite::gpu::gl::data::ObjectVariant object_type() const {
    return static_cast<tflite::gpu::gl::data::ObjectVariant>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const tflite::gpu::gl::data::ObjectData *object_as_ObjectData() const {
    return object_type() == tflite::gpu::gl::data::ObjectVariant::ObjectData ? static_cast<const tflite::gpu::gl::data::ObjectData *>(object()) : nullptr;
  }
  const tflite::gpu::gl::data::ObjectRef *object_as_ObjectRef() const {
    return object_type() == tflite::gpu::gl::data::ObjectVariant::ObjectRef ? static_cast<const tflite::gpu::gl::data::ObjectRef *>(object()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACCESS) &&
           VerifyField<uint32_t>(verifier, VT_BINDING) &&
           VerifyField<int8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_SIZE_TYPE) &&
           VerifyOffset(verifier, VT_SIZE) &&
           VerifyObjectSize(verifier, size(), size_type()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           VerifyObjectVariant(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
  ObjectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObjectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Object> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const tflite::gpu::gl::data::Uint1 *Object::size_as<tflite::gpu::gl::data::Uint1>() const {
  return size_as_Uint1();
}

template<> inline const tflite::gpu::gl::data::Uint2 *Object::size_as<tflite::gpu::gl::data::Uint2>() const {
  return size_as_Uint2();
}

template<> inline const tflite::gpu::gl::data::Uint3 *Object::size_as<tflite::gpu::gl::data::Uint3>() const {
  return size_as_Uint3();
}

template<> inline const tflite::gpu::gl::data::ObjectData *Object::object_as<tflite::gpu::gl::data::ObjectData>() const {
  return object_as_ObjectData();
}

template<> inline const tflite::gpu::gl::data::ObjectRef *Object::object_as<tflite::gpu::gl::data::ObjectRef>() const {
  return object_as_ObjectRef();
}

struct ObjectBuilder {
  typedef Object Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_access(tflite::gpu::gl::data::AccessType access) {
    fbb_.AddElement<int8_t>(Object::VT_ACCESS, static_cast<int8_t>(access), 0);
  }
  void add_binding(uint32_t binding) {
    fbb_.AddElement<uint32_t>(Object::VT_BINDING, binding, 0);
  }
  void add_data_type(tflite::gpu::gl::data::DataType data_type) {
    fbb_.AddElement<int8_t>(Object::VT_DATA_TYPE, static_cast<int8_t>(data_type), 0);
  }
  void add_type(tflite::gpu::gl::data::ObjectType type) {
    fbb_.AddElement<int8_t>(Object::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_size_type(tflite::gpu::gl::data::ObjectSize size_type) {
    fbb_.AddElement<uint8_t>(Object::VT_SIZE_TYPE, static_cast<uint8_t>(size_type), 0);
  }
  void add_size(flatbuffers::Offset<void> size) {
    fbb_.AddOffset(Object::VT_SIZE, size);
  }
  void add_object_type(tflite::gpu::gl::data::ObjectVariant object_type) {
    fbb_.AddElement<uint8_t>(Object::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Object::VT_OBJECT, object);
  }
  explicit ObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Object>(end);
    return o;
  }
};

inline flatbuffers::Offset<Object> CreateObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    tflite::gpu::gl::data::AccessType access = tflite::gpu::gl::data::AccessType::READ,
    uint32_t binding = 0,
    tflite::gpu::gl::data::DataType data_type = tflite::gpu::gl::data::DataType::UNKNOWN,
    tflite::gpu::gl::data::ObjectType type = tflite::gpu::gl::data::ObjectType::UNKNOWN,
    tflite::gpu::gl::data::ObjectSize size_type = tflite::gpu::gl::data::ObjectSize::NONE,
    flatbuffers::Offset<void> size = 0,
    tflite::gpu::gl::data::ObjectVariant object_type = tflite::gpu::gl::data::ObjectVariant::NONE,
    flatbuffers::Offset<void> object = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_size(size);
  builder_.add_binding(binding);
  builder_.add_object_type(object_type);
  builder_.add_size_type(size_type);
  builder_.add_type(type);
  builder_.add_data_type(data_type);
  builder_.add_access(access);
  return builder_.Finish();
}

flatbuffers::Offset<Object> CreateObject(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ObjectRefT : public flatbuffers::NativeTable {
  typedef ObjectRef TableType;
  uint32_t global_id = 0;
};

struct ObjectRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectRefT NativeTableType;
  typedef ObjectRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GLOBAL_ID = 4
  };
  uint32_t global_id() const {
    return GetField<uint32_t>(VT_GLOBAL_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GLOBAL_ID) &&
           verifier.EndTable();
  }
  ObjectRefT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObjectRefT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ObjectRef> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectRefT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObjectRefBuilder {
  typedef ObjectRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_global_id(uint32_t global_id) {
    fbb_.AddElement<uint32_t>(ObjectRef::VT_GLOBAL_ID, global_id, 0);
  }
  explicit ObjectRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectRef> CreateObjectRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t global_id = 0) {
  ObjectRefBuilder builder_(_fbb);
  builder_.add_global_id(global_id);
  return builder_.Finish();
}

flatbuffers::Offset<ObjectRef> CreateObjectRef(flatbuffers::FlatBufferBuilder &_fbb, const ObjectRefT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ObjectDataT : public flatbuffers::NativeTable {
  typedef ObjectData TableType;
  std::vector<uint8_t> data{};
};

struct ObjectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectDataT NativeTableType;
  typedef ObjectDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  ObjectDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObjectDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ObjectData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObjectDataBuilder {
  typedef ObjectData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ObjectData::VT_DATA, data);
  }
  explicit ObjectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectData> CreateObjectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ObjectDataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectData> CreateObjectDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return tflite::gpu::gl::data::CreateObjectData(
      _fbb,
      data__);
}

flatbuffers::Offset<ObjectData> CreateObjectData(flatbuffers::FlatBufferBuilder &_fbb, const ObjectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CompiledModelT : public flatbuffers::NativeTable {
  typedef CompiledModel TableType;
  std::unique_ptr<tflite::gpu::gl::data::ParametersT> parameters{};
  std::vector<std::string> shaders{};
  std::vector<std::unique_ptr<tflite::gpu::gl::data::ProgramT>> programs{};
};

struct CompiledModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompiledModelT NativeTableType;
  typedef CompiledModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETERS = 4,
    VT_SHADERS = 6,
    VT_PROGRAMS = 8
  };
  const tflite::gpu::gl::data::Parameters *parameters() const {
    return GetPointer<const tflite::gpu::gl::data::Parameters *>(VT_PARAMETERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *shaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SHADERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::Program>> *programs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::Program>> *>(VT_PROGRAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyTable(parameters()) &&
           VerifyOffset(verifier, VT_SHADERS) &&
           verifier.VerifyVector(shaders()) &&
           verifier.VerifyVectorOfStrings(shaders()) &&
           VerifyOffset(verifier, VT_PROGRAMS) &&
           verifier.VerifyVector(programs()) &&
           verifier.VerifyVectorOfTables(programs()) &&
           verifier.EndTable();
  }
  CompiledModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CompiledModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CompiledModel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CompiledModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CompiledModelBuilder {
  typedef CompiledModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_parameters(flatbuffers::Offset<tflite::gpu::gl::data::Parameters> parameters) {
    fbb_.AddOffset(CompiledModel::VT_PARAMETERS, parameters);
  }
  void add_shaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> shaders) {
    fbb_.AddOffset(CompiledModel::VT_SHADERS, shaders);
  }
  void add_programs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::Program>>> programs) {
    fbb_.AddOffset(CompiledModel::VT_PROGRAMS, programs);
  }
  explicit CompiledModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompiledModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompiledModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompiledModel> CreateCompiledModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<tflite::gpu::gl::data::Parameters> parameters = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> shaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::gl::data::Program>>> programs = 0) {
  CompiledModelBuilder builder_(_fbb);
  builder_.add_programs(programs);
  builder_.add_shaders(shaders);
  builder_.add_parameters(parameters);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompiledModel> CreateCompiledModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<tflite::gpu::gl::data::Parameters> parameters = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *shaders = nullptr,
    const std::vector<flatbuffers::Offset<tflite::gpu::gl::data::Program>> *programs = nullptr) {
  auto shaders__ = shaders ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*shaders) : 0;
  auto programs__ = programs ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::gl::data::Program>>(*programs) : 0;
  return tflite::gpu::gl::data::CreateCompiledModel(
      _fbb,
      parameters,
      shaders__,
      programs__);
}

flatbuffers::Offset<CompiledModel> CreateCompiledModel(flatbuffers::FlatBufferBuilder &_fbb, const CompiledModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ParametersT : public flatbuffers::NativeTable {
  typedef Parameters TableType;
  bool dynamic_batch = false;
};

struct Parameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParametersT NativeTableType;
  typedef ParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DYNAMIC_BATCH = 4
  };
  bool dynamic_batch() const {
    return GetField<uint8_t>(VT_DYNAMIC_BATCH, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMIC_BATCH) &&
           verifier.EndTable();
  }
  ParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Parameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ParametersBuilder {
  typedef Parameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dynamic_batch(bool dynamic_batch) {
    fbb_.AddElement<uint8_t>(Parameters::VT_DYNAMIC_BATCH, static_cast<uint8_t>(dynamic_batch), 0);
  }
  explicit ParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Parameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Parameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<Parameters> CreateParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool dynamic_batch = false) {
  ParametersBuilder builder_(_fbb);
  builder_.add_dynamic_batch(dynamic_batch);
  return builder_.Finish();
}

flatbuffers::Offset<Parameters> CreateParameters(flatbuffers::FlatBufferBuilder &_fbb, const ParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ProgramT *Program::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProgramT>(new ProgramT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Program::UnPackTo(ProgramT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = objects(); if (_e) { _o->objects.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->objects[_i] = std::unique_ptr<tflite::gpu::gl::data::ObjectT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = parameters(); if (_e) { _o->parameters.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->parameters[_i] = std::unique_ptr<tflite::gpu::gl::data::UniformParameterT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = number_workgroups(); if (_e) _o->number_workgroups = std::unique_ptr<tflite::gpu::gl::data::Uint3T>(_e->UnPack(_resolver)); }
  { auto _e = workgroup_size(); if (_e) _o->workgroup_size = std::unique_ptr<tflite::gpu::gl::data::Uint3T>(_e->UnPack(_resolver)); }
  { auto _e = shader_index(); _o->shader_index = _e; }
  { auto _e = binary(); if (_e) _o->binary = std::unique_ptr<tflite::gpu::gl::data::ProgramBinaryT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Program> Program::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgramT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProgram(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Program> CreateProgram(flatbuffers::FlatBufferBuilder &_fbb, const ProgramT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProgramT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _objects = _o->objects.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::gl::data::Object>> (_o->objects.size(), [](size_t i, _VectorArgs *__va) { return CreateObject(*__va->__fbb, __va->__o->objects[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _parameters = _o->parameters.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::gl::data::UniformParameter>> (_o->parameters.size(), [](size_t i, _VectorArgs *__va) { return CreateUniformParameter(*__va->__fbb, __va->__o->parameters[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _number_workgroups = _o->number_workgroups ? CreateUint3(_fbb, _o->number_workgroups.get(), _rehasher) : 0;
  auto _workgroup_size = _o->workgroup_size ? CreateUint3(_fbb, _o->workgroup_size.get(), _rehasher) : 0;
  auto _shader_index = _o->shader_index;
  auto _binary = _o->binary ? CreateProgramBinary(_fbb, _o->binary.get(), _rehasher) : 0;
  return tflite::gpu::gl::data::CreateProgram(
      _fbb,
      _objects,
      _parameters,
      _number_workgroups,
      _workgroup_size,
      _shader_index,
      _binary);
}

inline ProgramBinaryT *ProgramBinary::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProgramBinaryT>(new ProgramBinaryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProgramBinary::UnPackTo(ProgramBinaryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = binary(); if (_e) { _o->binary.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->binary.begin()); } }
}

inline flatbuffers::Offset<ProgramBinary> ProgramBinary::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgramBinaryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProgramBinary(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProgramBinary> CreateProgramBinary(flatbuffers::FlatBufferBuilder &_fbb, const ProgramBinaryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProgramBinaryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _binary = _o->binary.size() ? _fbb.CreateVector(_o->binary) : 0;
  return tflite::gpu::gl::data::CreateProgramBinary(
      _fbb,
      _format,
      _binary);
}

inline DataFloatT *DataFloat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DataFloatT>(new DataFloatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DataFloat::UnPackTo(DataFloatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<DataFloat> DataFloat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDataFloat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DataFloat> CreateDataFloat(flatbuffers::FlatBufferBuilder &_fbb, const DataFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DataFloatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return tflite::gpu::gl::data::CreateDataFloat(
      _fbb,
      _data);
}

inline DataInt32T *DataInt32::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DataInt32T>(new DataInt32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DataInt32::UnPackTo(DataInt32T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<DataInt32> DataInt32::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataInt32T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDataInt32(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DataInt32> CreateDataInt32(flatbuffers::FlatBufferBuilder &_fbb, const DataInt32T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DataInt32T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return tflite::gpu::gl::data::CreateDataInt32(
      _fbb,
      _data);
}

inline DataUint32T *DataUint32::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DataUint32T>(new DataUint32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DataUint32::UnPackTo(DataUint32T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<DataUint32> DataUint32::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataUint32T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDataUint32(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DataUint32> CreateDataUint32(flatbuffers::FlatBufferBuilder &_fbb, const DataUint32T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DataUint32T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return tflite::gpu::gl::data::CreateDataUint32(
      _fbb,
      _data);
}

inline UniformParameterT *UniformParameter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniformParameterT>(new UniformParameterT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniformParameter::UnPackTo(UniformParameterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = tflite::gpu::gl::data::DataVariantUnion::UnPack(_e, data_type(), _resolver); }
}

inline flatbuffers::Offset<UniformParameter> UniformParameter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniformParameterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniformParameter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UniformParameter> CreateUniformParameter(flatbuffers::FlatBufferBuilder &_fbb, const UniformParameterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UniformParameterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return tflite::gpu::gl::data::CreateUniformParameter(
      _fbb,
      _name,
      _type,
      _data_type,
      _data);
}

inline ObjectT *Object::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ObjectT>(new ObjectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Object::UnPackTo(ObjectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = access(); _o->access = _e; }
  { auto _e = binding(); _o->binding = _e; }
  { auto _e = data_type(); _o->data_type = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = size_type(); _o->size.type = _e; }
  { auto _e = size(); if (_e) _o->size.value = tflite::gpu::gl::data::ObjectSizeUnion::UnPack(_e, size_type(), _resolver); }
  { auto _e = object_type(); _o->object.type = _e; }
  { auto _e = object(); if (_e) _o->object.value = tflite::gpu::gl::data::ObjectVariantUnion::UnPack(_e, object_type(), _resolver); }
}

inline flatbuffers::Offset<Object> Object::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObject(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Object> CreateObject(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ObjectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _access = _o->access;
  auto _binding = _o->binding;
  auto _data_type = _o->data_type;
  auto _type = _o->type;
  auto _size_type = _o->size.type;
  auto _size = _o->size.Pack(_fbb);
  auto _object_type = _o->object.type;
  auto _object = _o->object.Pack(_fbb);
  return tflite::gpu::gl::data::CreateObject(
      _fbb,
      _access,
      _binding,
      _data_type,
      _type,
      _size_type,
      _size,
      _object_type,
      _object);
}

inline ObjectRefT *ObjectRef::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ObjectRefT>(new ObjectRefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ObjectRef::UnPackTo(ObjectRefT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = global_id(); _o->global_id = _e; }
}

inline flatbuffers::Offset<ObjectRef> ObjectRef::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectRefT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObjectRef(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ObjectRef> CreateObjectRef(flatbuffers::FlatBufferBuilder &_fbb, const ObjectRefT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ObjectRefT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _global_id = _o->global_id;
  return tflite::gpu::gl::data::CreateObjectRef(
      _fbb,
      _global_id);
}

inline ObjectDataT *ObjectData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ObjectDataT>(new ObjectDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ObjectData::UnPackTo(ObjectDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline flatbuffers::Offset<ObjectData> ObjectData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObjectData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ObjectData> CreateObjectData(flatbuffers::FlatBufferBuilder &_fbb, const ObjectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ObjectDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return tflite::gpu::gl::data::CreateObjectData(
      _fbb,
      _data);
}

inline CompiledModelT *CompiledModel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CompiledModelT>(new CompiledModelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CompiledModel::UnPackTo(CompiledModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = parameters(); if (_e) _o->parameters = std::unique_ptr<tflite::gpu::gl::data::ParametersT>(_e->UnPack(_resolver)); }
  { auto _e = shaders(); if (_e) { _o->shaders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shaders[_i] = _e->Get(_i)->str(); } } }
  { auto _e = programs(); if (_e) { _o->programs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->programs[_i] = std::unique_ptr<tflite::gpu::gl::data::ProgramT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<CompiledModel> CompiledModel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CompiledModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCompiledModel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CompiledModel> CreateCompiledModel(flatbuffers::FlatBufferBuilder &_fbb, const CompiledModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CompiledModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _parameters = _o->parameters ? CreateParameters(_fbb, _o->parameters.get(), _rehasher) : 0;
  auto _shaders = _o->shaders.size() ? _fbb.CreateVectorOfStrings(_o->shaders) : 0;
  auto _programs = _o->programs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::gl::data::Program>> (_o->programs.size(), [](size_t i, _VectorArgs *__va) { return CreateProgram(*__va->__fbb, __va->__o->programs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::gpu::gl::data::CreateCompiledModel(
      _fbb,
      _parameters,
      _shaders,
      _programs);
}

inline ParametersT *Parameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ParametersT>(new ParametersT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Parameters::UnPackTo(ParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dynamic_batch(); _o->dynamic_batch = _e; }
}

inline flatbuffers::Offset<Parameters> Parameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Parameters> CreateParameters(flatbuffers::FlatBufferBuilder &_fbb, const ParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dynamic_batch = _o->dynamic_batch;
  return tflite::gpu::gl::data::CreateParameters(
      _fbb,
      _dynamic_batch);
}

inline bool VerifyDataVariant(flatbuffers::Verifier &verifier, const void *obj, DataVariant type) {
  switch (type) {
    case DataVariant::NONE: {
      return true;
    }
    case DataVariant::DataInt32: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::DataInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataVariant::DataFloat: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::DataFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataVariant::DataUint32: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::DataUint32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataVariant(
        verifier,  values->Get(i), types->GetEnum<DataVariant>(i))) {
      return false;
    }
  }
  return true;
}

inline void *DataVariantUnion::UnPack(const void *obj, DataVariant type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case DataVariant::DataInt32: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::DataInt32 *>(obj);
      return ptr->UnPack(resolver);
    }
    case DataVariant::DataFloat: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::DataFloat *>(obj);
      return ptr->UnPack(resolver);
    }
    case DataVariant::DataUint32: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::DataUint32 *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> DataVariantUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case DataVariant::DataInt32: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::DataInt32T *>(value);
      return CreateDataInt32(_fbb, ptr, _rehasher).Union();
    }
    case DataVariant::DataFloat: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::DataFloatT *>(value);
      return CreateDataFloat(_fbb, ptr, _rehasher).Union();
    }
    case DataVariant::DataUint32: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::DataUint32T *>(value);
      return CreateDataUint32(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline DataVariantUnion::DataVariantUnion(const DataVariantUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case DataVariant::DataInt32: {
      value = new tflite::gpu::gl::data::DataInt32T(*reinterpret_cast<tflite::gpu::gl::data::DataInt32T *>(u.value));
      break;
    }
    case DataVariant::DataFloat: {
      value = new tflite::gpu::gl::data::DataFloatT(*reinterpret_cast<tflite::gpu::gl::data::DataFloatT *>(u.value));
      break;
    }
    case DataVariant::DataUint32: {
      value = new tflite::gpu::gl::data::DataUint32T(*reinterpret_cast<tflite::gpu::gl::data::DataUint32T *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void DataVariantUnion::Reset() {
  switch (type) {
    case DataVariant::DataInt32: {
      auto ptr = reinterpret_cast<tflite::gpu::gl::data::DataInt32T *>(value);
      delete ptr;
      break;
    }
    case DataVariant::DataFloat: {
      auto ptr = reinterpret_cast<tflite::gpu::gl::data::DataFloatT *>(value);
      delete ptr;
      break;
    }
    case DataVariant::DataUint32: {
      auto ptr = reinterpret_cast<tflite::gpu::gl::data::DataUint32T *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = DataVariant::NONE;
}

inline bool VerifyObjectVariant(flatbuffers::Verifier &verifier, const void *obj, ObjectVariant type) {
  switch (type) {
    case ObjectVariant::NONE: {
      return true;
    }
    case ObjectVariant::ObjectData: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::ObjectData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectVariant::ObjectRef: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::ObjectRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyObjectVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObjectVariant(
        verifier,  values->Get(i), types->GetEnum<ObjectVariant>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ObjectVariantUnion::UnPack(const void *obj, ObjectVariant type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ObjectVariant::ObjectData: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::ObjectData *>(obj);
      return ptr->UnPack(resolver);
    }
    case ObjectVariant::ObjectRef: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::ObjectRef *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ObjectVariantUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ObjectVariant::ObjectData: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::ObjectDataT *>(value);
      return CreateObjectData(_fbb, ptr, _rehasher).Union();
    }
    case ObjectVariant::ObjectRef: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::ObjectRefT *>(value);
      return CreateObjectRef(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ObjectVariantUnion::ObjectVariantUnion(const ObjectVariantUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ObjectVariant::ObjectData: {
      value = new tflite::gpu::gl::data::ObjectDataT(*reinterpret_cast<tflite::gpu::gl::data::ObjectDataT *>(u.value));
      break;
    }
    case ObjectVariant::ObjectRef: {
      value = new tflite::gpu::gl::data::ObjectRefT(*reinterpret_cast<tflite::gpu::gl::data::ObjectRefT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ObjectVariantUnion::Reset() {
  switch (type) {
    case ObjectVariant::ObjectData: {
      auto ptr = reinterpret_cast<tflite::gpu::gl::data::ObjectDataT *>(value);
      delete ptr;
      break;
    }
    case ObjectVariant::ObjectRef: {
      auto ptr = reinterpret_cast<tflite::gpu::gl::data::ObjectRefT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ObjectVariant::NONE;
}

inline bool VerifyObjectSize(flatbuffers::Verifier &verifier, const void *obj, ObjectSize type) {
  switch (type) {
    case ObjectSize::NONE: {
      return true;
    }
    case ObjectSize::Uint1: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::Uint1 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectSize::Uint2: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::Uint2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectSize::Uint3: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::Uint3 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyObjectSizeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObjectSize(
        verifier,  values->Get(i), types->GetEnum<ObjectSize>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ObjectSizeUnion::UnPack(const void *obj, ObjectSize type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ObjectSize::Uint1: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::Uint1 *>(obj);
      return ptr->UnPack(resolver);
    }
    case ObjectSize::Uint2: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::Uint2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case ObjectSize::Uint3: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::Uint3 *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ObjectSizeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ObjectSize::Uint1: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::Uint1T *>(value);
      return CreateUint1(_fbb, ptr, _rehasher).Union();
    }
    case ObjectSize::Uint2: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::Uint2T *>(value);
      return CreateUint2(_fbb, ptr, _rehasher).Union();
    }
    case ObjectSize::Uint3: {
      auto ptr = reinterpret_cast<const tflite::gpu::gl::data::Uint3T *>(value);
      return CreateUint3(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ObjectSizeUnion::ObjectSizeUnion(const ObjectSizeUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ObjectSize::Uint1: {
      value = new tflite::gpu::gl::data::Uint1T(*reinterpret_cast<tflite::gpu::gl::data::Uint1T *>(u.value));
      break;
    }
    case ObjectSize::Uint2: {
      value = new tflite::gpu::gl::data::Uint2T(*reinterpret_cast<tflite::gpu::gl::data::Uint2T *>(u.value));
      break;
    }
    case ObjectSize::Uint3: {
      value = new tflite::gpu::gl::data::Uint3T(*reinterpret_cast<tflite::gpu::gl::data::Uint3T *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ObjectSizeUnion::Reset() {
  switch (type) {
    case ObjectSize::Uint1: {
      auto ptr = reinterpret_cast<tflite::gpu::gl::data::Uint1T *>(value);
      delete ptr;
      break;
    }
    case ObjectSize::Uint2: {
      auto ptr = reinterpret_cast<tflite::gpu::gl::data::Uint2T *>(value);
      delete ptr;
      break;
    }
    case ObjectSize::Uint3: {
      auto ptr = reinterpret_cast<tflite::gpu::gl::data::Uint3T *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ObjectSize::NONE;
}

inline const tflite::gpu::gl::data::CompiledModel *GetCompiledModel(const void *buf) {
  return flatbuffers::GetRoot<tflite::gpu::gl::data::CompiledModel>(buf);
}

inline const tflite::gpu::gl::data::CompiledModel *GetSizePrefixedCompiledModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<tflite::gpu::gl::data::CompiledModel>(buf);
}

inline const char *CompiledModelIdentifier() {
  return "AFCM";
}

inline bool CompiledModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, CompiledModelIdentifier());
}

inline bool VerifyCompiledModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::gpu::gl::data::CompiledModel>(CompiledModelIdentifier());
}

inline bool VerifySizePrefixedCompiledModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::gpu::gl::data::CompiledModel>(CompiledModelIdentifier());
}

inline const char *CompiledModelExtension() {
  return "flow";
}

inline void FinishCompiledModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::gpu::gl::data::CompiledModel> root) {
  fbb.Finish(root, CompiledModelIdentifier());
}

inline void FinishSizePrefixedCompiledModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::gpu::gl::data::CompiledModel> root) {
  fbb.FinishSizePrefixed(root, CompiledModelIdentifier());
}

inline std::unique_ptr<tflite::gpu::gl::data::CompiledModelT> UnPackCompiledModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::gpu::gl::data::CompiledModelT>(GetCompiledModel(buf)->UnPack(res));
}

inline std::unique_ptr<tflite::gpu::gl::data::CompiledModelT> UnPackSizePrefixedCompiledModel(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::gpu::gl::data::CompiledModelT>(GetSizePrefixedCompiledModel(buf)->UnPack(res));
}

}  // namespace data
}  // namespace gl
}  // namespace gpu
}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_COMPILEDMODEL_TFLITE_GPU_GL_DATA_H_
